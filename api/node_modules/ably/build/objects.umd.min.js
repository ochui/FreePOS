/*@license Copyright 2015-2022 Ably Real-time Ltd (ably.com)

Ably JavaScript Library v2.12.0
https://github.com/ably/ably-js

Released under the Apache Licence v2.0*/(function (g, f) {
    if ("object" == typeof exports && "object" == typeof module) {
      module.exports = f();
    } else if ("function" == typeof define && define.amd) {
      define([], f);
    } else if ("object" == typeof exports) {
      exports["AblyObjectsPlugin"] = f();
    } else {
      g["AblyObjectsPlugin"] = f();
    }
  }(this, () => {
var exports = {};
var module = { exports };
"use strict";var A=Object.defineProperty,H=Object.defineProperties,Q=Object.getOwnPropertyDescriptor,X=Object.getOwnPropertyDescriptors,ee=Object.getOwnPropertyNames,w=Object.getOwnPropertySymbols;var $=Object.prototype.hasOwnProperty,z=Object.prototype.propertyIsEnumerable;var k=(s,t)=>{if(t=Symbol[s])return t;throw Error("Symbol."+s+" is not defined")};var W=(s,t,e)=>t in s?A(s,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[t]=e,O=(s,t)=>{for(var e in t||(t={}))$.call(t,e)&&W(s,e,t[e]);if(w)for(var e of w(t))z.call(t,e)&&W(s,e,t[e]);return s},_=(s,t)=>H(s,X(t));var K=(s,t)=>{var e={};for(var i in s)$.call(s,i)&&t.indexOf(i)<0&&(e[i]=s[i]);if(s!=null&&w)for(var i of w(s))t.indexOf(i)<0&&z.call(s,i)&&(e[i]=s[i]);return e};var te=(s,t)=>{for(var e in t)A(s,e,{get:t[e],enumerable:!0})},ie=(s,t,e,i)=>{if(t&&typeof t=="object"||typeof t=="function")for(let a of ee(t))!$.call(s,a)&&a!==e&&A(s,a,{get:()=>t[a],enumerable:!(i=Q(t,a))||i.enumerable});return s};var ae=s=>ie(A({},"__esModule",{value:!0}),s);var se=function(s,t){this[0]=s,this[1]=t};var P=s=>{var t=s[k("asyncIterator")],e=!1,i,a={};return t==null?(t=s[k("iterator")](),i=n=>a[n]=r=>t[n](r)):(t=t.call(s),i=n=>a[n]=r=>{if(e){if(e=!1,n==="throw")throw r;return r}return e=!0,{done:!1,value:new se(new Promise(o=>{var c=t[n](r);if(!(c instanceof Object))throw TypeError("Object expected");o(c)}),1)}}),a[k("iterator")]=()=>a,i("next"),"throw"in t?i("throw"):a.throw=n=>{throw n},"return"in t&&i("return"),a};var oe={};te(oe,{ObjectMessage:()=>b,Objects:()=>C,WireObjectMessage:()=>y,default:()=>re});module.exports=ae(oe);function F(s,t,e,i){var n,r,o,c,p,d,l,h,g,m,L,D;let a=Object.assign(new y(t,e),G(s));return(r=(n=s.object)==null?void 0:n.map)!=null&&r.entries&&(a.object.map.entries=B(s.object.map.entries,i)),(p=(c=(o=s.object)==null?void 0:o.createOp)==null?void 0:c.map)!=null&&p.entries&&(a.object.createOp.map.entries=B(s.object.createOp.map.entries,i)),(h=(l=(d=s.object)==null?void 0:d.createOp)==null?void 0:l.mapOp)!=null&&h.data&&(a.object.createOp.mapOp.data=V(s.object.createOp.mapOp.data,i)),(m=(g=s.operation)==null?void 0:g.map)!=null&&m.entries&&(a.operation.map.entries=B(s.operation.map.entries,i)),(D=(L=s.operation)==null?void 0:L.mapOp)!=null&&D.data&&(a.operation.mapOp.data=V(s.operation.mapOp.data,i)),a}function B(s,t){return Object.entries(s).reduce((e,i)=>{let[a,n]=i,r=n.data?V(n.data,t):void 0;return e[a]=_(O({},n),{data:r}),e},{})}function V(s,t){return t(s)}function x(s,t){let i=b.fromValues({operation:s},t.Utils,t.MessageEncoding).encode(t),{operation:a}=i.encodeForWire(t.Utils.Format.json);return JSON.stringify(a)}function J(s,t){let e="["+t;for(let i in s)s[i]===void 0||i==="_utils"||i==="_messageEncoding"||(i==="operation"||i==="object"||i==="extras"?e+=`; ${i}=${JSON.stringify(s[i])}`:e+=`; ${i}=${s[i]}`);return e+="]",e}function G(s){let t={id:s.id,clientId:s.clientId,connectionId:s.connectionId,timestamp:s.timestamp,serial:s.serial,serialTimestamp:s.serialTimestamp,siteCode:s.siteCode};return s.operation&&(t.operation=JSON.parse(JSON.stringify(s.operation))),s.object&&(t.object=JSON.parse(JSON.stringify(s.object))),s.extras&&(t.extras=JSON.parse(JSON.stringify(s.extras))),t}var b=class s{constructor(t,e){this._utils=t;this._messageEncoding=e}static fromValues(t,e,i){return Object.assign(new s(e,i),t)}static fromValuesArray(t,e,i){return t.map(a=>s.fromValues(a,e,i))}encode(t){let e=i=>{let a={objectId:i.objectId};return t.Platform.BufferUtils.isBuffer(i.value)?a.bytes=i.value:typeof i.value=="string"?a.string=i.value:typeof i.value=="boolean"?a.boolean=i.value:typeof i.value=="number"?a.number=i.value:typeof i.value=="object"&&i.value!==null&&(a.json=JSON.stringify(i.value)),a};return F(this,this._utils,this._messageEncoding,e)}toString(){return J(this,"ObjectMessage")}},y=class s{constructor(t,e){this._utils=t;this._messageEncoding=e}static fromValues(t,e,i){return Object.assign(new s(e,i),t)}static fromValuesArray(t,e,i){return t.map(a=>s.fromValues(a,e,i))}encodeForWire(t){let e=i=>{if(i.bytes!=null){let a=this._messageEncoding.encodeDataForWire(i.bytes,null,t);return _(O({},i),{bytes:a.data})}return O({},i)};return F(this,this._utils,this._messageEncoding,e)}decode(t,e){var a,n,r,o,c,p,d,l,h,g,m,L;let i=Object.assign(new b(this._utils,this._messageEncoding),G(this));try{(n=(a=this.object)==null?void 0:a.map)!=null&&n.entries&&(i.object.map.entries=this._decodeMapEntries(this.object.map.entries,t,e)),(c=(o=(r=this.object)==null?void 0:r.createOp)==null?void 0:o.map)!=null&&c.entries&&(i.object.createOp.map.entries=this._decodeMapEntries(this.object.createOp.map.entries,t,e)),(l=(d=(p=this.object)==null?void 0:p.createOp)==null?void 0:d.mapOp)!=null&&l.data&&(i.object.createOp.mapOp.data=this._decodeObjectData(this.object.createOp.mapOp.data,t,e)),(g=(h=this.operation)==null?void 0:h.map)!=null&&g.entries&&(i.operation.map.entries=this._decodeMapEntries(this.operation.map.entries,t,e)),(L=(m=this.operation)==null?void 0:m.mapOp)!=null&&L.data&&(i.operation.mapOp.data=this._decodeObjectData(this.operation.mapOp.data,t,e))}catch(D){t.Logger.logAction(t.logger,t.Logger.LOG_ERROR,"WireObjectMessage.decode()",this._utils.inspectError(D))}return i}toJSON(){let t=arguments.length>0?this._utils.Format.json:this._utils.Format.msgpack,n=this.encodeForWire(t),{_utils:e,_messageEncoding:i}=n;return K(n,["_utils","_messageEncoding"])}toString(){return J(this,"WireObjectMessage")}getMessageSize(){var e,i;let t=0;return t+=(i=(e=this.clientId)==null?void 0:e.length)!=null?i:0,this.operation&&(t+=this._getObjectOperationSize(this.operation)),this.object&&(t+=this._getObjectStateSize(this.object)),this.extras&&(t+=JSON.stringify(this.extras).length),t}_getObjectOperationSize(t){let e=0;return t.mapOp&&(e+=this._getMapOpSize(t.mapOp)),t.counterOp&&(e+=this._getCounterOpSize(t.counterOp)),t.map&&(e+=this._getObjectMapSize(t.map)),t.counter&&(e+=this._getObjectCounterSize(t.counter)),e}_getObjectStateSize(t){let e=0;return t.map&&(e+=this._getObjectMapSize(t.map)),t.counter&&(e+=this._getObjectCounterSize(t.counter)),t.createOp&&(e+=this._getObjectOperationSize(t.createOp)),e}_getObjectMapSize(t){var i;let e=0;return Object.entries((i=t.entries)!=null?i:{}).forEach(([a,n])=>{var r;e+=(r=a==null?void 0:a.length)!=null?r:0,n&&(e+=this._getMapEntrySize(n))}),e}_getObjectCounterSize(t){return t.count==null?0:8}_getMapEntrySize(t){let e=0;return t.data&&(e+=this._getObjectDataSize(t.data)),e}_getMapOpSize(t){var i,a;let e=0;return e+=(a=(i=t.key)==null?void 0:i.length)!=null?a:0,t.data&&(e+=this._getObjectDataSize(t.data)),e}_getCounterOpSize(t){return t.amount==null?0:8}_getObjectDataSize(t){let e=0;return t.boolean!=null&&(e+=this._utils.dataSizeBytes(t.boolean)),t.bytes!=null&&(e+=this._utils.dataSizeBytes(t.bytes)),t.number!=null&&(e+=this._utils.dataSizeBytes(t.number)),t.string!=null&&(e+=this._utils.dataSizeBytes(t.string)),t.json!=null&&(e+=this._utils.dataSizeBytes(t.json)),e}_decodeMapEntries(t,e,i){return Object.entries(t).reduce((a,n)=>{let[r,o]=n,c=o.data?this._decodeObjectData(o.data,e,i):void 0;return a[r]=_(O({},o),{data:c}),a},{})}_decodeObjectData(t,e,i){var a,n,r;try{let o;t.bytes!=null&&(o=i==="msgpack"?t.bytes:e.Platform.BufferUtils.base64Decode(String(t.bytes)));let c;return t.json!=null&&(c=JSON.parse(t.json)),{objectId:t.objectId,value:(r=(n=(a=o!=null?o:c)!=null?a:t.boolean)!=null?n:t.number)!=null?r:t.string}}catch(o){return e.Logger.logAction(e.logger,e.Logger.LOG_ERROR,"WireObjectMessage._decodeObjectData()",this._utils.inspectError(o)),O({},t)}}};var j=class{constructor(t,e){this._objects=t;this._client=this._objects.getClient(),this._subscriptions=new this._client.EventEmitter(this._client.logger),this._lifecycleEvents=new this._client.EventEmitter(this._client.logger),this._objectId=e,this._dataRef=this._getZeroValueData(),this._siteTimeserials={},this._createOperationIsMerged=!1,this._tombstone=!1}subscribe(t){return this._objects.throwIfInvalidAccessApiConfiguration(),this._subscriptions.on("updated",t),{unsubscribe:()=>{this._subscriptions.off("updated",t)}}}unsubscribe(t){this._client.Utils.isNil(t)||this._subscriptions.off("updated",t)}unsubscribeAll(){this._subscriptions.off("updated")}on(t,e){return this._lifecycleEvents.on(t,e),{off:()=>{this._lifecycleEvents.off(t,e)}}}off(t,e){this._client.Utils.isNil(t)&&this._client.Utils.isNil(e)||this._lifecycleEvents.off(t,e)}offAll(){this._lifecycleEvents.off()}getObjectId(){return this._objectId}notifyUpdated(t){t.noop||this._subscriptions.emit("updated",t)}tombstone(t){this._tombstone=!0,t.serialTimestamp!=null?this._tombstonedAt=t.serialTimestamp:(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"LiveObject.tombstone()",`object has been tombstoned but no "serialTimestamp" found in the message, using local clock instead; objectId=${this.getObjectId()}`),this._tombstonedAt=Date.now());let e=this.clearData();return e.clientId=t.clientId,this._lifecycleEvents.emit("deleted"),e}isTombstoned(){return this._tombstone}tombstonedAt(){return this._tombstonedAt}clearData(){let t=this._dataRef;return this._dataRef=this._getZeroValueData(),this._updateFromDataDiff(t,this._dataRef)}_canApplyOperation(t,e){if(!t)throw new this._client.ErrorInfo(`Invalid serial: ${t}`,92e3,500);if(!e)throw new this._client.ErrorInfo(`Invalid site code: ${e}`,92e3,500);let i=this._siteTimeserials[e];return!i||t>i}_applyObjectDelete(t){return this.tombstone(t)}};var v=class s{constructor(t,e,i){this.type=t;this.hash=e;this.msTimestamp=i}static fromInitialValue(t,e,i,a,n){let r=t.BufferUtils.concat([t.BufferUtils.utf8Encode(i),t.BufferUtils.utf8Encode(":"),t.BufferUtils.utf8Encode(a)]),o=t.BufferUtils.sha256(r),c=t.BufferUtils.base64UrlEncode(o);return new s(e,c,n)}static fromString(t,e){if(t.Utils.isNil(e))throw new t.ErrorInfo("Invalid object id string",92e3,500);let[i,a]=e.split(":");if(!i||!a)throw new t.ErrorInfo("Invalid object id string",92e3,500);if(!["map","counter"].includes(i))throw new t.ErrorInfo(`Invalid object type in object id: ${e}`,92e3,500);let[n,r]=a.split("@");if(!n||!r)throw new t.ErrorInfo("Invalid object id string",92e3,500);if(!Number.isInteger(Number.parseInt(r)))throw new t.ErrorInfo("Invalid object id string",92e3,500);return new s(i,n,Number.parseInt(r))}toString(){return`${this.type}:${this.hash}@${this.msTimestamp}`}};var f=class s extends j{static zeroValue(t,e){return new s(t,e)}static fromObjectState(t,e){let i=new s(t,e.object.objectId);return i.overrideWithObjectState(e),i}static fromObjectOperation(t,e){let i=new s(t,e.operation.objectId);return i._mergeInitialDataFromCreateOperation(e.operation,e),i}static createCounterIncMessage(t,e,i){let a=t.getClient();if(typeof i!="number"||!Number.isFinite(i))throw new a.ErrorInfo("Counter value increment should be a valid number",40003,400);return b.fromValues({operation:{action:4,objectId:e,counterOp:{amount:i}}},a.Utils,a.MessageEncoding)}static async createCounterCreateMessage(t,e){let i=t.getClient();if(e!==void 0&&(typeof e!="number"||!Number.isFinite(e)))throw new i.ErrorInfo("Counter value should be a valid number",40003,400);let a=s.createInitialValueOperation(e),n=x(a,i),r=i.Utils.cheapRandStr(),o=await i.getTimestamp(!0),c=v.fromInitialValue(i.Platform,"counter",n,r,o).toString();return b.fromValues({operation:_(O({},a),{action:3,objectId:c,nonce:r,initialValue:n})},i.Utils,i.MessageEncoding)}static createInitialValueOperation(t){return{counter:{count:t!=null?t:0}}}value(){return this._objects.throwIfInvalidAccessApiConfiguration(),this._dataRef.data}async increment(t){this._objects.throwIfInvalidWriteApiConfiguration();let e=s.createCounterIncMessage(this._objects,this.getObjectId(),t);return this._objects.publish([e])}async decrement(t){if(this._objects.throwIfInvalidWriteApiConfiguration(),typeof t!="number"||!Number.isFinite(t))throw new this._client.ErrorInfo("Counter value decrement should be a valid number",40003,400);return this.increment(-t)}applyOperation(t,e){var r;if(t.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Cannot apply object operation with objectId=${t.objectId}, to this LiveCounter with objectId=${this.getObjectId()}`,92e3,500);let i=e.serial,a=e.siteCode;if(!this._canApplyOperation(i,a)){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveCounter.applyOperation()",`skipping ${t.action} op: op serial ${i.toString()} <= site serial ${(r=this._siteTimeserials[a])==null?void 0:r.toString()}; objectId=${this.getObjectId()}`);return}if(this._siteTimeserials[a]=i,this.isTombstoned())return;let n;switch(t.action){case 3:n=this._applyCounterCreate(t,e);break;case 4:if(this._client.Utils.isNil(t.counterOp)){this._throwNoPayloadError(t);return}else n=this._applyCounterInc(t.counterOp,e);break;case 5:n=this._applyObjectDelete(e);break;default:throw new this._client.ErrorInfo(`Invalid ${t.action} op for LiveCounter objectId=${this.getObjectId()}`,92e3,500)}this.notifyUpdated(n)}overrideWithObjectState(t){var n,r,o,c,p;let e=t.object;if(e==null)throw new this._client.ErrorInfo(`Missing object state; LiveCounter objectId=${this.getObjectId()}`,92e3,500);if(e.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state objectId=${e.objectId}; LiveCounter objectId=${this.getObjectId()}`,92e3,500);if(!this._client.Utils.isNil(e.createOp)){if(e.createOp.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state createOp objectId=${(n=e.createOp)==null?void 0:n.objectId}; LiveCounter objectId=${this.getObjectId()}`,92e3,500);if(e.createOp.action!==3)throw new this._client.ErrorInfo(`Invalid object state: object state createOp action=${(r=e.createOp)==null?void 0:r.action}; LiveCounter objectId=${this.getObjectId()}`,92e3,500)}if(this._siteTimeserials=(o=e.siteTimeserials)!=null?o:{},this.isTombstoned())return{noop:!0};let i=this._dataRef;e.tombstone?this.tombstone(t):(this._createOperationIsMerged=!1,this._dataRef={data:(p=(c=e.counter)==null?void 0:c.count)!=null?p:0},this._client.Utils.isNil(e.createOp)||this._mergeInitialDataFromCreateOperation(e.createOp,t));let a=this._updateFromDataDiff(i,this._dataRef);return a.clientId=t.clientId,a}onGCInterval(){}_getZeroValueData(){return{data:0}}_updateFromDataDiff(t,e){return{update:{amount:e.data-t.data}}}_mergeInitialDataFromCreateOperation(t,e){var i,a,n,r;return this._dataRef.data+=(a=(i=t.counter)==null?void 0:i.count)!=null?a:0,this._createOperationIsMerged=!0,{update:{amount:(r=(n=t.counter)==null?void 0:n.count)!=null?r:0},clientId:e.clientId}}_throwNoPayloadError(t){throw new this._client.ErrorInfo(`No payload found for ${t.action} op for LiveCounter objectId=${this.getObjectId()}`,92e3,500)}_applyCounterCreate(t,e){return this._createOperationIsMerged?(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveCounter._applyCounterCreate()",`skipping applying COUNTER_CREATE op on a counter instance as it was already applied before; objectId=${this.getObjectId()}`),{noop:!0}):this._mergeInitialDataFromCreateOperation(t,e)}_applyCounterInc(t,e){return this._dataRef.data+=t.amount,{update:{amount:t.amount},clientId:e.clientId}}};var S=class{constructor(t,e,i){this._batchContext=t;this._objects=e;this._counter=i;this._client=this._objects.getClient()}value(){return this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),this._counter.value()}increment(t){this._objects.throwIfInvalidWriteApiConfiguration(),this._batchContext.throwIfClosed();let e=f.createCounterIncMessage(this._objects,this._counter.getObjectId(),t);this._batchContext.queueMessage(e)}decrement(t){if(this._objects.throwIfInvalidWriteApiConfiguration(),this._batchContext.throwIfClosed(),typeof t!="number")throw new this._client.ErrorInfo("Counter value decrement should be a number",40003,400);this.increment(-t)}};var Z=Object.prototype.hasOwnProperty;function Y(s,t,e){for(e of s.keys())if(I(e,t))return e}function I(s,t){var e,i,a;if(s===t)return!0;if(s&&t&&(e=s.constructor)===t.constructor){if(e===Date)return s.getTime()===t.getTime();if(e===RegExp)return s.toString()===t.toString();if(e===Array){if((i=s.length)===t.length)for(;i--&&I(s[i],t[i]););return i===-1}if(e===Set){if(s.size!==t.size)return!1;for(i of s)if(a=i,a&&typeof a=="object"&&(a=Y(t,a),!a)||!t.has(a))return!1;return!0}if(e===Map){if(s.size!==t.size)return!1;for(i of s)if(a=i[0],a&&typeof a=="object"&&(a=Y(t,a),!a)||!I(i[1],t.get(a)))return!1;return!0}if(e===ArrayBuffer)s=new Uint8Array(s),t=new Uint8Array(t);else if(e===DataView){if((i=s.byteLength)===t.byteLength)for(;i--&&s.getInt8(i)===t.getInt8(i););return i===-1}if(ArrayBuffer.isView(s)){if((i=s.byteLength)===t.byteLength)for(;i--&&s[i]===t[i];);return i===-1}if(!e||typeof s=="object"){i=0;for(e in s)if(Z.call(s,e)&&++i&&!Z.call(t,e)||!(e in t)||!I(s[e],t[e]))return!1;return Object.keys(t).length===i}}return s!==s&&t!==t}var u=class s extends j{constructor(e,i,a){super(e,a);this._semantics=i}static zeroValue(e,i){return new s(e,0,i)}static fromObjectState(e,i){let a=new s(e,i.object.map.semantics,i.object.objectId);return a.overrideWithObjectState(i),a}static fromObjectOperation(e,i){var n;let a=new s(e,(n=i.operation.map)==null?void 0:n.semantics,i.operation.objectId);return a._mergeInitialDataFromCreateOperation(i.operation,i),a}static createMapSetMessage(e,i,a,n){let r=e.getClient();s.validateKeyValue(e,a,n);let o;return n instanceof j?o={objectId:n.getObjectId()}:o={value:n},b.fromValues({operation:{action:1,objectId:i,mapOp:{key:a,data:o}}},r.Utils,r.MessageEncoding)}static createMapRemoveMessage(e,i,a){let n=e.getClient();if(typeof a!="string")throw new n.ErrorInfo("Map key should be string",40003,400);return b.fromValues({operation:{action:2,objectId:i,mapOp:{key:a}}},n.Utils,n.MessageEncoding)}static validateKeyValue(e,i,a){let n=e.getClient();if(typeof i!="string")throw new n.ErrorInfo("Map key should be string",40003,400);if(a===null||typeof a!="string"&&typeof a!="number"&&typeof a!="boolean"&&typeof a!="object")throw new n.ErrorInfo("Map value data type is unsupported",40013,400)}static async createMapCreateMessage(e,i){let a=e.getClient();if(i!==void 0&&(i===null||typeof i!="object"))throw new a.ErrorInfo("Map entries should be a key-value object",40003,400);Object.entries(i!=null?i:{}).forEach(([l,h])=>s.validateKeyValue(e,l,h));let n=s.createInitialValueOperation(i),r=x(n,a),o=a.Utils.cheapRandStr(),c=await a.getTimestamp(!0),p=v.fromInitialValue(a.Platform,"map",r,o,c).toString();return b.fromValues({operation:_(O({},n),{action:0,objectId:p,nonce:o,initialValue:r})},a.Utils,a.MessageEncoding)}static createInitialValueOperation(e){let i={};return Object.entries(e!=null?e:{}).forEach(([a,n])=>{let r;n instanceof j?r={objectId:n.getObjectId()}:r={value:n},i[a]={data:r}}),{map:{semantics:0,entries:i}}}get(e){if(this._objects.throwIfInvalidAccessApiConfiguration(),this.isTombstoned())return;let i=this._dataRef.data.get(e);if(i!==void 0&&i.tombstone!==!0)return this._getResolvedValueFromObjectData(i.data)}size(){this._objects.throwIfInvalidAccessApiConfiguration();let e=0;for(let i of this._dataRef.data.values())this._isMapEntryTombstoned(i)||e++;return e}*entries(){this._objects.throwIfInvalidAccessApiConfiguration();for(let[e,i]of this._dataRef.data.entries()){if(this._isMapEntryTombstoned(i))continue;let a=this._getResolvedValueFromObjectData(i.data);yield[e,a]}}*keys(){for(let[e]of this.entries())yield e}*values(){for(let[e,i]of this.entries())yield i}async set(e,i){this._objects.throwIfInvalidWriteApiConfiguration();let a=s.createMapSetMessage(this._objects,this.getObjectId(),e,i);return this._objects.publish([a])}async remove(e){this._objects.throwIfInvalidWriteApiConfiguration();let i=s.createMapRemoveMessage(this._objects,this.getObjectId(),e);return this._objects.publish([i])}applyOperation(e,i){var o;if(e.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Cannot apply object operation with objectId=${e.objectId}, to this LiveMap with objectId=${this.getObjectId()}`,92e3,500);let a=i.serial,n=i.siteCode;if(!this._canApplyOperation(a,n)){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap.applyOperation()",`skipping ${e.action} op: op serial ${a.toString()} <= site serial ${(o=this._siteTimeserials[n])==null?void 0:o.toString()}; objectId=${this.getObjectId()}`);return}if(this._siteTimeserials[n]=a,this.isTombstoned())return;let r;switch(e.action){case 0:r=this._applyMapCreate(e,i);break;case 1:if(this._client.Utils.isNil(e.mapOp)){this._throwNoPayloadError(e);return}else r=this._applyMapSet(e.mapOp,a,i);break;case 2:if(this._client.Utils.isNil(e.mapOp)){this._throwNoPayloadError(e);return}else r=this._applyMapRemove(e.mapOp,a,i.serialTimestamp,i);break;case 5:r=this._applyObjectDelete(i);break;default:throw new this._client.ErrorInfo(`Invalid ${e.action} op for LiveMap objectId=${this.getObjectId()}`,92e3,500)}this.notifyUpdated(r)}overrideWithObjectState(e){var r,o,c,p,d,l,h,g,m;let i=e.object;if(i==null)throw new this._client.ErrorInfo(`Missing object state; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(i.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state objectId=${i.objectId}; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(((r=i.map)==null?void 0:r.semantics)!==this._semantics)throw new this._client.ErrorInfo(`Invalid object state: object state map semantics=${(o=i.map)==null?void 0:o.semantics}; LiveMap semantics=${this._semantics}`,92e3,500);if(!this._client.Utils.isNil(i.createOp)){if(i.createOp.objectId!==this.getObjectId())throw new this._client.ErrorInfo(`Invalid object state: object state createOp objectId=${(c=i.createOp)==null?void 0:c.objectId}; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(i.createOp.action!==0)throw new this._client.ErrorInfo(`Invalid object state: object state createOp action=${(p=i.createOp)==null?void 0:p.action}; LiveMap objectId=${this.getObjectId()}`,92e3,500);if(((d=i.createOp.map)==null?void 0:d.semantics)!==this._semantics)throw new this._client.ErrorInfo(`Invalid object state: object state createOp map semantics=${(l=i.createOp.map)==null?void 0:l.semantics}; LiveMap semantics=${this._semantics}`,92e3,500)}if(this._siteTimeserials=(h=i.siteTimeserials)!=null?h:{},this.isTombstoned())return{noop:!0};let a=this._dataRef;i.tombstone?this.tombstone(e):(this._createOperationIsMerged=!1,this._dataRef=this._liveMapDataFromMapEntries((m=(g=i.map)==null?void 0:g.entries)!=null?m:{}),this._client.Utils.isNil(i.createOp)||this._mergeInitialDataFromCreateOperation(i.createOp,e));let n=this._updateFromDataDiff(a,this._dataRef);return n.clientId=e.clientId,n}onGCInterval(){let e=[];for(let[i,a]of this._dataRef.data.entries())a.tombstone===!0&&Date.now()-a.tombstonedAt>=this._objects.gcGracePeriod&&e.push(i);e.forEach(i=>this._dataRef.data.delete(i))}_getZeroValueData(){return{data:new Map}}_updateFromDataDiff(e,i){let a={update:{}};for(let[n,r]of e.data.entries()){let o=n;r.tombstone===!1&&!i.data.has(o)&&(a.update[o]="removed")}for(let[n,r]of i.data.entries()){let o=n;if(!e.data.has(o)){if(r.tombstone===!1){a.update[o]="updated";continue}if(r.tombstone===!0)continue}let c=e.data.get(o);if(c.tombstone===!0&&r.tombstone===!1){a.update[o]="updated";continue}if(c.tombstone===!1&&r.tombstone===!0){a.update[o]="removed";continue}if(c.tombstone===!0&&r.tombstone===!0)continue;if(!I(c.data,r.data)){a.update[o]="updated";continue}}return a}_mergeInitialDataFromCreateOperation(e,i){var n;if(this._client.Utils.isNil(e.map))return{update:{},clientId:i.clientId};let a={update:{},clientId:i.clientId};return Object.entries((n=e.map.entries)!=null?n:{}).forEach(([r,o])=>{let c=o.timeserial,p;o.tombstone===!0?p=this._applyMapRemove({key:r},c,o.serialTimestamp,i):p=this._applyMapSet({key:r,data:o.data},c,i),!p.noop&&Object.assign(a.update,p.update)}),this._createOperationIsMerged=!0,a}_throwNoPayloadError(e){throw new this._client.ErrorInfo(`No payload found for ${e.action} op for LiveMap objectId=${this.getObjectId()}`,92e3,500)}_applyMapCreate(e,i){var a,n;if(this._createOperationIsMerged)return this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap._applyMapCreate()",`skipping applying MAP_CREATE op on a map instance as it was already applied before; objectId=${this.getObjectId()}`),{noop:!0};if(this._semantics!==((a=e.map)==null?void 0:a.semantics))throw new this._client.ErrorInfo(`Cannot apply MAP_CREATE op on LiveMap objectId=${this.getObjectId()}; map's semantics=${this._semantics}, but op expected ${(n=e.map)==null?void 0:n.semantics}`,92e3,500);return this._mergeInitialDataFromCreateOperation(e,i)}_applyMapSet(e,i,a){var l;let{ErrorInfo:n,Utils:r}=this._client,o=this._dataRef.data.get(e.key);if(o&&!this._canApplyMapOperation(o.timeserial,i))return this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap._applyMapSet()",`skipping update for key="${e.key}": op serial ${i==null?void 0:i.toString()} <= entry serial ${(l=o.timeserial)==null?void 0:l.toString()}; objectId=${this.getObjectId()}`),{noop:!0};if(r.isNil(e.data)||r.isNil(e.data.objectId)&&r.isNil(e.data.value))throw new n(`Invalid object data for MAP_SET op on objectId=${this.getObjectId()} on key="${e.key}"`,92e3,500);let c;if(r.isNil(e.data.objectId)?c={value:e.data.value}:(c={objectId:e.data.objectId},this._objects.getPool().createZeroValueObjectIfNotExists(e.data.objectId)),o)o.tombstone=!1,o.tombstonedAt=void 0,o.timeserial=i,o.data=c;else{let h={tombstone:!1,tombstonedAt:void 0,timeserial:i,data:c};this._dataRef.data.set(e.key,h)}let p={update:{},clientId:a.clientId},d=e.key;return p.update[d]="updated",p}_applyMapRemove(e,i,a,n){var d;let r=this._dataRef.data.get(e.key);if(r&&!this._canApplyMapOperation(r.timeserial,i))return this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MICRO,"LiveMap._applyMapRemove()",`skipping remove for key="${e.key}": op serial ${i==null?void 0:i.toString()} <= entry serial ${(d=r.timeserial)==null?void 0:d.toString()}; objectId=${this.getObjectId()}`),{noop:!0};let o;if(a!=null?o=a:(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"LiveMap._applyMapRemove()",`map key has been removed but no "serialTimestamp" found in the message, using local clock instead; key="${e.key}", objectId=${this.getObjectId()}`),o=Date.now()),r)r.tombstone=!0,r.tombstonedAt=o,r.timeserial=i,r.data=void 0;else{let l={tombstone:!0,tombstonedAt:o,timeserial:i,data:void 0};this._dataRef.data.set(e.key,l)}let c={update:{},clientId:n.clientId},p=e.key;return c.update[p]="removed",c}_canApplyMapOperation(e,i){return!e&&!i?!1:e?i?i>e:!1:!0}_liveMapDataFromMapEntries(e){let i={data:new Map};return Object.entries(e!=null?e:{}).forEach(([a,n])=>{let r;this._client.Utils.isNil(n.data)||(this._client.Utils.isNil(n.data.objectId)?r={value:n.data.value}:r={objectId:n.data.objectId});let o;n.tombstone===!0&&(n.serialTimestamp!=null?o=n.serialTimestamp:(this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"LiveMap._liveMapDataFromMapEntries()",`map key is removed but no "serialTimestamp" found, using local clock instead; key="${a}", objectId=${this.getObjectId()}`),o=Date.now()));let c={timeserial:n.timeserial,data:r,tombstone:n.tombstone===!0,tombstonedAt:o};i.data.set(a,c)}),i}_getResolvedValueFromObjectData(e){let i=e.value;if(i!=null)return i;let a=e.objectId,n=this._objects.getPool().get(a);if(n&&!n.isTombstoned())return n}_isMapEntryTombstoned(e){if(e.tombstone===!0)return!0;let i=e.data;if("objectId"in i){let a=this._objects.getPool().get(i.objectId);if(a!=null&&a.isTombstoned())return!0}return!1}};var T=class{constructor(t,e,i){this._batchContext=t;this._objects=e;this._map=i}get(t){this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed();let e=this._map.get(t);return e instanceof j?this._batchContext.getWrappedObject(e.getObjectId()):e}size(){return this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),this._map.size()}*entries(){this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),yield*P(this._map.entries())}*keys(){this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),yield*P(this._map.keys())}*values(){this._objects.throwIfInvalidAccessApiConfiguration(),this._batchContext.throwIfClosed(),yield*P(this._map.values())}set(t,e){this._objects.throwIfInvalidWriteApiConfiguration(),this._batchContext.throwIfClosed();let i=u.createMapSetMessage(this._objects,this._map.getObjectId(),t,e);this._batchContext.queueMessage(i)}remove(t){this._objects.throwIfInvalidWriteApiConfiguration(),this._batchContext.throwIfClosed();let e=u.createMapRemoveMessage(this._objects,this._map.getObjectId(),t);this._batchContext.queueMessage(e)}};var M={gcInterval:3e5,gcGracePeriod:864e5};var E="root",U=class{constructor(t){this._objects=t;var e,i;this._client=this._objects.getClient(),this._pool=this._createInitialPool(),this._gcInterval=setInterval(()=>{this._onGCInterval()},M.gcInterval),(i=(e=this._gcInterval).unref)==null||i.call(e)}get(t){return this._pool.get(t)}deleteExtraObjectIds(t){[...this._pool.keys()].filter(a=>!t.includes(a)).forEach(a=>this._pool.delete(a))}set(t,e){this._pool.set(t,e)}resetToInitialPool(t){let e=this._pool.get(E);this._pool.clear(),this._pool.set(e.getObjectId(),e),this.clearObjectsData(t)}clearObjectsData(t){for(let e of this._pool.values()){let i=e.clearData();t&&e.notifyUpdated(i)}}createZeroValueObjectIfNotExists(t){let e=this.get(t);if(e)return e;let i=v.fromString(this._client,t),a;switch(i.type){case"map":{a=u.zeroValue(this._objects,t);break}case"counter":a=f.zeroValue(this._objects,t);break}return this.set(t,a),a}_createInitialPool(){let t=new Map,e=u.zeroValue(this._objects,E);return t.set(e.getObjectId(),e),t}_onGCInterval(){let t=[];for(let[e,i]of this._pool.entries()){if(i.isTombstoned()&&Date.now()-i.tombstonedAt()>=this._objects.gcGracePeriod){t.push(e);continue}i.onGCInterval()}t.forEach(e=>this._pool.delete(e))}};var R=class{constructor(t,e){this._objects=t;this._root=e;this._wrappedObjects=new Map;this._queuedMessages=[];this._isClosed=!1;this._client=t.getClient(),this._wrappedObjects.set(this._root.getObjectId(),new T(this,this._objects,this._root))}getRoot(){return this._objects.throwIfInvalidAccessApiConfiguration(),this.throwIfClosed(),this.getWrappedObject(E)}getWrappedObject(t){if(this._wrappedObjects.has(t))return this._wrappedObjects.get(t);let e=this._objects.getPool().get(t);if(!e)return;let i;if(e instanceof u)i=new T(this,this._objects,e);else if(e instanceof f)i=new S(this,this._objects,e);else throw new this._client.ErrorInfo(`Unknown LiveObject instance type: objectId=${e.getObjectId()}`,5e4,500);return this._wrappedObjects.set(t,i),i}throwIfClosed(){if(this.isClosed())throw new this._client.ErrorInfo("Batch is closed",4e4,400)}isClosed(){return this._isClosed}close(){this._isClosed=!0}queueMessage(t){this._queuedMessages.push(t)}async flush(){try{this.close(),this._queuedMessages.length>0&&await this._objects.publish(this._queuedMessages)}finally{this._wrappedObjects.clear(),this._queuedMessages=[]}}};var N=class{constructor(t){this._objects=t;this._client=this._objects.getClient(),this._channel=this._objects.getChannel(),this._pool=new Map}entries(){return this._pool.entries()}size(){return this._pool.size}isEmpty(){return this._pool.size===0}clear(){this._pool.clear()}applyObjectSyncMessages(t){for(let e of t){if(!e.object){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"SyncObjectsDataPool.applyObjectSyncMessages()",`object message is received during OBJECT_SYNC without 'object' field, skipping message; message id: ${e.id}, channel: ${this._channel.name}`);continue}let i=e.object;i.counter?this._pool.set(i.objectId,this._createLiveCounterDataEntry(e)):i.map?this._pool.set(i.objectId,this._createLiveMapDataEntry(e)):this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"SyncObjectsDataPool.applyObjectSyncMessages()",`received unsupported object state message during OBJECT_SYNC, expected 'counter' or 'map' to be present, skipping message; message id: ${e.id}, channel: ${this._channel.name}`)}}_createLiveCounterDataEntry(t){return{objectMessage:t,objectType:"LiveCounter"}}_createLiveMapDataEntry(t){return{objectMessage:t,objectType:"LiveMap"}}};var ne={initialized:void 0,syncing:"syncing",synced:"synced"},C=class{constructor(t){var e,i;this._channel=t,this._client=t.client,this._state="initialized",this._eventEmitterInternal=new this._client.EventEmitter(this._client.logger),this._eventEmitterPublic=new this._client.EventEmitter(this._client.logger),this._objectsPool=new U(this),this._syncObjectsDataPool=new N(this),this._bufferedObjectOperations=[],this.gcGracePeriod=(i=(e=this._channel.connectionManager.connectionDetails)==null?void 0:e.objectsGCGracePeriod)!=null?i:M.gcGracePeriod,this._channel.connectionManager.on("connectiondetails",a=>{var n;this.gcGracePeriod=(n=a.objectsGCGracePeriod)!=null?n:M.gcGracePeriod})}async getRoot(){return this.throwIfInvalidAccessApiConfiguration(),this._state!=="synced"&&await this._eventEmitterInternal.once("synced"),this._objectsPool.get(E)}async batch(t){this.throwIfInvalidWriteApiConfiguration();let e=await this.getRoot(),i=new R(this,e);try{t(i),await i.flush()}finally{i.close()}}async createMap(t){var n;this.throwIfInvalidWriteApiConfiguration();let e=await u.createMapCreateMessage(this,t),i=(n=e.operation)==null?void 0:n.objectId;if(await this.publish([e]),this._objectsPool.get(i))return this._objectsPool.get(i);let a=u.fromObjectOperation(this,e);return this._objectsPool.set(i,a),a}async createCounter(t){var n;this.throwIfInvalidWriteApiConfiguration();let e=await f.createCounterCreateMessage(this,t),i=(n=e.operation)==null?void 0:n.objectId;if(await this.publish([e]),this._objectsPool.get(i))return this._objectsPool.get(i);let a=f.fromObjectOperation(this,e);return this._objectsPool.set(i,a),a}on(t,e){return this._eventEmitterPublic.on(t,e),{off:()=>{this._eventEmitterPublic.off(t,e)}}}off(t,e){this._client.Utils.isNil(t)&&this._client.Utils.isNil(e)||this._eventEmitterPublic.off(t,e)}offAll(){this._eventEmitterPublic.off()}getPool(){return this._objectsPool}getChannel(){return this._channel}getClient(){return this._client}handleObjectSyncMessages(t,e){let{syncId:i,syncCursor:a}=this._parseSyncChannelSerial(e),n=this._currentSyncId!==i;n&&this._startNewSync(i,a),this._syncObjectsDataPool.applyObjectSyncMessages(t),a||this._endSync(n)}handleObjectMessages(t){if(this._state!=="synced"){this._bufferedObjectOperations.push(...t);return}this._applyObjectMessages(t)}onAttached(t){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MINOR,"Objects.onAttached()",`channel=${this._channel.name}, hasObjects=${t}`);let e=this._state==="initialized";(t||e)&&this._startNewSync(),t||(this._objectsPool.resetToInitialPool(!0),this._syncObjectsDataPool.clear(),this._endSync(e))}actOnChannelState(t,e){switch(t){case"attached":this.onAttached(e);break;case"detached":case"failed":this._objectsPool.clearObjectsData(!1),this._syncObjectsDataPool.clear();break}}async publish(t){this._channel.throwIfUnpublishableState();let e=t.map(n=>n.encode(this._client)),i=this._client.options.maxMessageSize,a=e.reduce((n,r)=>n+r.getMessageSize(),0);if(a>i)throw new this._client.ErrorInfo(`Maximum size of object messages that can be published at once exceeded (was ${a} bytes; limit is ${i} bytes)`,40009,400);return this._channel.sendState(e)}throwIfInvalidAccessApiConfiguration(){this._throwIfMissingChannelMode("object_subscribe"),this._throwIfInChannelState(["detached","failed"])}throwIfInvalidWriteApiConfiguration(){this._throwIfMissingChannelMode("object_publish"),this._throwIfInChannelState(["detached","failed","suspended"]),this._throwIfEchoMessagesDisabled()}_startNewSync(t,e){this._bufferedObjectOperations=[],this._syncObjectsDataPool.clear(),this._currentSyncId=t,this._currentSyncCursor=e,this._stateChange("syncing",!1)}_endSync(t){this._applySync(),this._applyObjectMessages(this._bufferedObjectOperations),this._bufferedObjectOperations=[],this._syncObjectsDataPool.clear(),this._currentSyncId=void 0,this._currentSyncCursor=void 0,this._stateChange("synced",t)}_parseSyncChannelSerial(t){let e,i,a;return t&&(e=t.match(/^([\w-]+):(.*)$/))&&(i=e[1],a=e[2]),{syncId:i,syncCursor:a}}_applySync(){if(this._syncObjectsDataPool.isEmpty())return;let t=new Set,e=[];for(let[i,a]of this._syncObjectsDataPool.entries()){t.add(i);let n=this._objectsPool.get(i);if(n){let c=n.overrideWithObjectState(a.objectMessage);e.push({object:n,update:c});continue}let r,o=a.objectType;switch(o){case"LiveCounter":r=f.fromObjectState(this,a.objectMessage);break;case"LiveMap":r=u.fromObjectState(this,a.objectMessage);break;default:throw new this._client.ErrorInfo(`Unknown LiveObject type: ${o}`,5e4,500)}this._objectsPool.set(i,r)}this._objectsPool.deleteExtraObjectIds([...t]),e.forEach(({object:i,update:a})=>i.notifyUpdated(a))}_applyObjectMessages(t){for(let e of t){if(!e.operation){this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"Objects._applyObjectMessages()",`object operation message is received without 'operation' field, skipping message; message id: ${e.id}, channel: ${this._channel.name}`);continue}let i=e.operation;switch(i.action){case 0:case 3:case 1:case 2:case 4:case 5:this._objectsPool.createZeroValueObjectIfNotExists(i.objectId),this._objectsPool.get(i.objectId).applyOperation(i,e);break;default:this._client.Logger.logAction(this._client.logger,this._client.Logger.LOG_MAJOR,"Objects._applyObjectMessages()",`received unsupported action in object operation message: ${i.action}, skipping message; message id: ${e.id}, channel: ${this._channel.name}`)}}}_throwIfMissingChannelMode(t){var e;if(this._channel.modes!=null&&!this._channel.modes.includes(t))throw new this._client.ErrorInfo(`"${t}" channel mode must be set for this operation`,40024,400);if(!this._client.Utils.allToLowerCase((e=this._channel.channelOptions.modes)!=null?e:[]).includes(t))throw new this._client.ErrorInfo(`"${t}" channel mode must be set for this operation`,40024,400)}_stateChange(t,e){if(this._state===t)return;this._state=t;let i=ne[t];i&&(e?this._client.Platform.Config.nextTick(()=>{this._eventEmitterInternal.emit(i),this._eventEmitterPublic.emit(i)}):(this._eventEmitterInternal.emit(i),this._eventEmitterPublic.emit(i)))}_throwIfInChannelState(t){if(t.includes(this._channel.state))throw this._client.ErrorInfo.fromValues(this._channel.invalidStateError())}_throwIfEchoMessagesDisabled(){if(this._channel.client.options.echoMessages===!1)throw new this._channel.client.ErrorInfo('"echoMessages" client option must be enabled for this operation',4e4,400)}};C._DEFAULTS=M;var re={Objects:C,ObjectMessage:b,WireObjectMessage:y};
if (typeof module.exports == "object" && typeof exports == "object") {
  var __cp = (to, from, except, desc) => {
    if ((from && typeof from === "object") || typeof from === "function") {
      for (let key of Object.getOwnPropertyNames(from)) {
        if (!Object.prototype.hasOwnProperty.call(to, key) && key !== except)
        Object.defineProperty(to, key, {
          get: () => from[key],
          enumerable: !(desc = Object.getOwnPropertyDescriptor(from, key)) || desc.enumerable,
        });
      }
    }
    return to;
  };
  module.exports = __cp(module.exports, exports);
}
return module.exports;
}))
//# sourceMappingURL=objects.umd.min.js.map
